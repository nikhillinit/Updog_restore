import { describe, it, expect } from 'vitest';
import { xirrNewtonBisection } from '@/lib/finance/xirr';

describe('XIRR Calculation', () => {
  it('should calculate exact IRR for simple two-point case', () => {
    const flows = [
      { date: new Date('2020-01-01'), amount: -100000 },
      { date: new Date('2025-01-01'), amount: 200000 }
    ];
    
    const result = xirrNewtonBisection(flows);
    
    expect(result.converged).toBe(true);
    expect(result.irr).toBeDefined();
    // ~14.87% annual return for doubling in 5 years
    expect(result.irr! * 100).toBeCloseTo(14.87, 1);
  });

  it('should handle irregular cash flow spacing', () => {
    const flows = [
      { date: new Date('2020-01-01'), amount: -100000 },
      { date: new Date('2021-06-15'), amount: 30000 },
      { date: new Date('2022-12-31'), amount: 40000 },
      { date: new Date('2024-03-01'), amount: 60000 }
    ];
    
    const result = xirrNewtonBisection(flows);
    
    expect(result.converged).toBe(true);
    expect(result.irr).toBeDefined();
    expect(result.irr!).toBeGreaterThan(0);
  });

  it('should return null for all negative flows', () => {
    const flows = [
      { date: new Date('2020-01-01'), amount: -100000 },
      { date: new Date('2021-01-01'), amount: -50000 }
    ];
    
    const result = xirrNewtonBisection(flows);
    
    expect(result.converged).toBe(false);
    expect(result.irr).toBeNull();
    expect(result.method).toBe('none');
  });

  it('should return null for all positive flows', () => {
    const flows = [
      { date: new Date('2020-01-01'), amount: 100000 },
      { date: new Date('2021-01-01'), amount: 50000 }
    ];
    
    const result = xirrNewtonBisection(flows);
    
    expect(result.converged).toBe(false);
    expect(result.irr).toBeNull();
  });

  it('should fallback to bisection when Newton fails', () => {
    // Create a pathological case that might fail Newton
    const flows = [
      { date: new Date('2020-01-01'), amount: -100000 },
      { date: new Date('2020-02-01'), amount: 200000 },
      { date: new Date('2020-03-01'), amount: -150000 },
      { date: new Date('2020-04-01'), amount: 80000 }
    ];
    
    const result = xirrNewtonBisection(flows, 0.1, 1e-7, 100);
    
    expect(result.converged).toBe(true);
    expect(result.method).toMatch(/newton|bisection/);
  });

  it('should handle zero return correctly', () => {
    const flows = [
      { date: new Date('2020-01-01'), amount: -100000 },
      { date: new Date('2021-01-01'), amount: 100000 }
    ];
    
    const result = xirrNewtonBisection(flows);
    
    expect(result.converged).toBe(true);
    expect(result.irr).toBeCloseTo(0, 3);
  });

  it('should handle very high returns', () => {
    const flows = [
      { date: new Date('2020-01-01'), amount: -100000 },
      { date: new Date('2020-06-01'), amount: 500000 } // 5x in 5 months
    ];
    
    const result = xirrNewtonBisection(flows);
    
    expect(result.converged).toBe(true);
    expect(result.irr).toBeGreaterThan(1); // >100% annual return
  });

  it('should respect tolerance parameter', () => {
    const flows = [
      { date: new Date('2020-01-01'), amount: -100000 },
      { date: new Date('2025-01-01'), amount: 200000 }
    ];
    
    const looseTolerance = xirrNewtonBisection(flows, 0.1, 1e-3);
    const tightTolerance = xirrNewtonBisection(flows, 0.1, 1e-10);
    
    expect(looseTolerance.iterations).toBeLessThan(tightTolerance.iterations);
    expect(Math.abs(looseTolerance.irr! - tightTolerance.irr!)).toBeLessThan(1e-3);
  });
});

describe('XIRR Edge Cases', () => {
  it('should handle empty flows', () => {
    const result = xirrNewtonBisection([]);
    
    expect(result.converged).toBe(false);
    expect(result.irr).toBeNull();
    expect(result.iterations).toBe(0);
  });

  it('should handle single flow', () => {
    const flows = [{ date: new Date('2020-01-01'), amount: -100000 }];
    const result = xirrNewtonBisection(flows);
    
    expect(result.converged).toBe(false);
    expect(result.irr).toBeNull();
  });

  it('should sort flows by date automatically', () => {
    const flows = [
      { date: new Date('2025-01-01'), amount: 200000 },
      { date: new Date('2020-01-01'), amount: -100000 } // Out of order
    ];
    
    const result = xirrNewtonBisection(flows);
    
    expect(result.converged).toBe(true);
    expect(result.irr! * 100).toBeCloseTo(14.87, 1);
  });
});