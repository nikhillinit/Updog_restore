Response to Implementation

**Where we are (grounded):**

* Core stage‑validation infrastructure is in place (mode resolver, RFC‑compliant headers scaffolding, shared schemas, metrics), and the **DB + scripts for normalization/backup are complete and production‑ready**. 
* The **Monte Carlo normalization bug** was fixed by replacing the brittle regex with a typed, fail‑closed normalizer; related statistical tests were upgraded. 
* A handoff memo enumerates **Phase 4–6** as remaining work: hook 3 API routes, add tests (unit/integration/perf), alerts/runbook/OpenAPI/docs, then execute a 6–9 day staged rollout. 

**What Claude surfaced (accurate & actionable):**

* Some items claimed “ready” still need **verification** (alerts file, enhanced observability, runbook, full green tests).
* Avoid **duplicate tests** and **metrics cardinality bombs** (e.g., `ua_hash`). Prefer **structured logs** for offenders.
* Use **Alertmanager webhooks** for near‑instant auto‑downgrade (vs. cron), define **concrete RTO/RPO**, add **exit criteria** for extended “warn”.
* **150+ modified client files** must be staged or split so they don’t contaminate Stage Validation PRs.

**What this plan does:**

* Reconciles duplication risks (reuse/extend existing perf suites),
* Implements safer observability (no high‑cardinality labels),
* Adds the missing glue (auto‑downgrade webhook, backup freshness, runbook, alerts),
* Locks a **Day 3+ timeline** that starts exactly where the repo is today, and
* Keeps NotebookLM pragmatic (simple gate + human checklist) so it doesn’t block.

---

## 2) What’s confirmed vs. pending

**Confirmed in repo (don’t rebuild, just use):**

* **DB + scripts completed**: `migrations/20251030_stage_normalization_log.sql`, `scripts/backup-stages.sh`, `scripts/normalize-stages.ts` (transactional, parameterized, audit‑logged). 
* **Normalizer & tests**: typed stage normalizer, extensive unit tests; Monte Carlo tests refactored with rigorous statistics. 
* **Phase inventory** & file list showing what remains for Phases 4–6 (routes, tests, alerts, docs, rollout). 

**Pending / needs verification before rollout:**

* Prometheus **alert rules** file, **runbook**, **OpenAPI header docs**, **route wiring** for 3 endpoints, and **green test runs**. 

---

## 3) Risks addressed (Claude’s critique → corrective actions)

1. **Duplicate work / tests**
   **Action:** Extend the existing perf suite (e.g., large‑array Monte Carlo) with a focused micro‑benchmark for normalization; don’t add a parallel perf tree. (See code harness below.)

2. **Cardinality bomb (ua_hash)**
   **Action:** Keep Prometheus labels **low‑cardinality** (“endpoint”, “mode”, “outcome” only) and log offenders as **structured JSON**. (Snippet below.)

3. **Slow auto‑rollback (cron)**
   **Action:** Use **Alertmanager → webhook** to flip `enforce → warn` within ~30s. Provide a **local fallback** toggle route in non‑prod only. (Config + handler below.)

4. **Missing backup freshness gate**
   **Action:** Add `assertFreshBackup()` used by the normalization script preflight. (Snippet below.)

5. **Ambiguous rollout windows**
   **Action:** Extend **warn** to 14 days **with exit criteria** and a **MAX_WARN_DURATION=30 days** cap. Define RTO/RPO targets and rollback thresholds (below).

6. **150+ modified client files**
   **Action:** Isolate immediately (branch/stash/PR) so Stage Validation work stays laser‑focused.

7. **NotebookLM over‑engineering**
   **Action:** Keep to: ≥92% LLM‑as‑Judge + human checklist. Calibrate later **only if** drift is observed.

---

## 4) Day‑by‑day plan (aligned to **Day 3+** reality)

> The handoff shows Phases **1–3 complete** and **4–6 remaining**. We start at Day 3 with route integration & tests. 

### **Day 3 — Route integration + perf “shift‑left”**

* Wire stage validation into **three endpoints** following the shared pattern (monte‑carlo, portfolio‑intelligence, allocations). Use the template in the memo. 
* Add a **minimal micro‑benchmark** (see code) that reuses the current perf scaffolding—**no duplicate suite**.
* **Isolate client churn**:

  ```bash
  # Capture unrelated client changes safely
  git switch -c chore/ui-wip-snapshot
  git add client/ && git commit -m "chore(ui): snapshot unrelated WIP (parking before stage validation)"
  git push -u origin chore/ui-wip-snapshot
  # Return to staged-validation branch (or main feature branch)
  git switch -  # back
  ```

### **Day 4 — Tests**

* Unit: modes off/warn/enforce (headers, metrics).
* Integration: 3× endpoints × 3 modes (9 scenarios).
* Perf: p95/p99 within budget; **record baseline**.
* Verify DB utilities run (dry‑run + help). **No prod writes yet.** 

### **Day 5 — Observability & docs**

* Add **Alertmanager rules** + **webhook** + **non‑prod toggle route**.
* Ship **runbook** and **OpenAPI** response headers schema; update ADR‑011 with Phase 2 notes. 
* **NotebookLM**: run LLM‑as‑Judge (existing framework) + quick human checklist (see gate below).

### **Days 6–9 — Rollout (off → warn → enforce)**

* **Day 6**: deploy **mode=off** (observe unknowns, adjust alias map).
* **Day 6 PM**: **mode=warn** (14‑day window).
* **Day 7 AM**: DB backup → dry‑run → apply normalization, then verify distinct stages. (Your scripts are ready.) 
* **Day 7 PM**: Canary **enforce** with auto‑downgrade triggers (Alertmanager).
* **Day 8–9**: Expand enforce as metrics allow; close out with docs + CHANGELOG entry. 

---

## 5) Concrete success criteria (hard gates)

**Operational targets**

* **RTO_TARGET**: < 30 minutes (rollback from enforce→warn via webhook).
* **RPO_TARGET**: < 1 hour (validated fresh DB backup before apply).
* **MAX_WARN_DURATION**: 30 days.
* **BLAST_RADIUS_THRESHOLD**: > 0.5% 4xx due to `INVALID_STAGE` over 10 min → auto‑downgrade to warn.
* **ERROR_RATE_ROLLBACK**: > 5% route error rate for 5 min → rollback to warn (and page).

**Performance**

* **Validation p99 < 1 ms** budget for normalization path (measured in isolation before full integration).

**Quality & docs**

* **All unit/integration/perf tests green**; runbook + OpenAPI updated; ADR‑011 amended with Phase 2 decisions. 
* **NotebookLM gate**: ≥92% LLM‑as‑Judge score **plus** a 10‑point human checklist (clarity, examples, edge‑cases).

---

## 6) Do not duplicate: reuse what you already have

* The **normalizer**, **DB scripts**, and **statistical tests** already exist—**do not** recreate perf suites; add a small targetted bench. 
* Follow the **exact three‑route integration pattern** from the memo, then implement tests and alerts **as specified**. 

---

## 7) Code drops (copy‑paste ready)

### A) Structured logging for “unknown stage” offenders (no cardinality labels)

```ts
// server/observability/stage-offender-log.ts
import { createHash } from 'crypto';
import { logger } from '../utils/logger'; // your existing logger

export function logUnknownStageOffender(req: any, endpoint: string, mode: 'off'|'warn'|'enforce', unknown: string[]) {
  const ua = String(req.headers['user-agent'] || '');
  const uaHash = createHash('sha256').update(ua).digest('hex').slice(0, 12);

  logger.warn('stage_validation_unknown', {
    endpoint,
    mode,
    unknownStages: unknown,
    uaHash,
    requestId: req.id,
    ts: new Date().toISOString(),
  });
}
```

> Keep Prometheus labels low‑cardinality (`endpoint`, `mode`, `outcome`) per your `stage-metrics.ts` design; offenders go to logs only. 

### B) Alertmanager webhook → auto‑downgrade (near‑instant rollback)

**Alertmanager receiver (snippet):**

```yaml
# prometheus/alerts/stage-normalization.yml
- alert: StageValidationBlastRadius
  expr: sum(rate(stage_validation_outcome_total{outcome="reject"}[5m])) > 0.005
  for: 10m
  labels: { severity: critical }
  annotations:
    summary: "High rejection rate on stage validation"
    runbook: "https://…/docs/runbooks/stage-normalization-rollout.md"
```

**Alertmanager route → webhook:**

```yaml
# alertmanager.yml
route:
  receiver: 'stage-validation-webhook'
receivers:
- name: 'stage-validation-webhook'
  webhook_configs:
  - url: 'https://internal-tools.example.com/_ops/stage-validation/auto-downgrade'
    send_resolved: true
    max_alerts: 5
```

**Webhook handler (non‑prod toggle also supported):**

```ts
// server/routes/_ops.stage-validation.ts
import express from 'express';
import { setStageValidationMode } from '../lib/stage-validation-mode-runtime'; // in-memory override

const router = express.Router();

router.post('/_ops/stage-validation/auto-downgrade', (req, res) => {
  // TODO: verify Alertmanager signature / shared secret header
  setStageValidationMode('warn');
  return res.json({ ok: true, mode: 'warn' });
});

// Optional manual toggle (disable in prod)
router.post('/_ops/stage-validation/toggle', (req, res) => {
  if (process.env.NODE_ENV === 'production') return res.sendStatus(403);
  const mode = req.body?.mode;
  if (!['off','warn','enforce'].includes(mode)) return res.status(400).json({ error: 'bad mode' });
  setStageValidationMode(mode as any);
  res.json({ ok: true, mode });
});

export default router;
```

**Runtime mode (env + in‑memory override):**

```ts
// server/lib/stage-validation-mode-runtime.ts
let override: 'off'|'warn'|'enforce'|null = null;
export function getStageValidationMode(): 'off'|'warn'|'enforce' {
  return (override ?? (process.env.STAGE_VALIDATION_MODE as any)) || 'warn';
}
export function setStageValidationMode(m: 'off'|'warn'|'enforce') { override = m; }
export function enforcesValidation() { return getStageValidationMode() === 'enforce'; }
export function allowsUnknownStages() { return getStageValidationMode() !== 'enforce'; }
```

> This keeps your existing env‑driven helper semantics while allowing safe, audited overrides via webhook.

### C) Backup freshness preflight (used by normalization script)

```ts
// scripts/lib/backup.ts
import { promises as fs } from 'fs';
import path from 'path';

export async function assertFreshBackup(maxAgeHours = 24) {
  const backupDir = path.join(__dirname, '../../backups'); // align to your layout
  const files = await fs.readdir(backupDir);
  if (!files.length) throw new Error('No backups found');
  const latest = files.sort().pop()!;
  const stat = await fs.stat(path.join(backupDir, latest));
  const ageHours = (Date.now() - stat.mtimeMs) / 36e5;
  if (ageHours > maxAgeHours) {
    throw new Error(`Backup too old: ${ageHours.toFixed(1)}h > ${maxAgeHours}h`);
  }
  return { latest, ageHours };
}
```

> Wire into `scripts/normalize-stages.ts` **before** `--apply`. Your migration script and backup tooling are already present and production‑grade. 

### D) Danger flag confirmation (`--force-unknown`)

```ts
// scripts/lib/confirm.ts
import readline from 'node:readline/promises';
import { stdin as input, stdout as output } from 'node:process';

export async function confirmDanger(message: string) {
  const rl = readline.createInterface({ input, output });
  const ans = (await rl.question(`${message}\nType "CONFIRM" to proceed: `)).trim();
  rl.close();
  if (ans !== 'CONFIRM') throw new Error('Aborted by user');
}

// usage in normalize-stages.ts
if (argv.forceUnknown) {
  await confirmDanger('You are enabling --force-unknown in production.');
}
```

### E) Micro‑benchmark harness (shift‑left perf)

```ts
// tests/perf/stage-normalization.microbench.test.ts
import { performance } from 'node:perf_hooks';
import { parseStageDistribution } from '@shared/schemas/parse-stage-distribution';

function bench(fn: () => void, iters = 50_000) {
  const t0 = performance.now();
  for (let i = 0; i < iters; i++) fn();
  const t1 = performance.now();
  const perCallMs = (t1 - t0) / iters;
  return perCallMs;
}

test('normalization fast path p99 budget', () => {
  const cases = [
    { stageDistribution: { 'pre_seed': 0.1, 'Series-A': 0.9 } },
    { stageDistribution: { 'series-c+': 1.0 } },
  ];
  const perCallMs = bench(() => parseStageDistribution(cases[0] as any), 100_000);
  // p99 budget proxy: be stricter than your 1ms target
  expect(perCallMs).toBeLessThan(0.02); // 20µs avg proxy; validate on CI perf runner
});
```

> Keep this with your **existing** perf tests—no parallel tree.

---

## 8) Runbook, alerts & docs (quick outlines)

**Runbook (`docs/runbooks/stage-normalization-rollout.md`):**

* Preflight: green tests; **backup fresh <24h**; Alertmanager webhooks reachable; config includes thresholds.
* Day 6: deploy `off` → observe → alias map update procedure.
* Day 6 PM: switch `warn` → verify headers `/api/deprecations`.
* Day 7 AM: backup → dry‑run → **apply** → verify `SELECT DISTINCT stage …`.
* Day 7 PM: **canary enforce**; rollback triggers + webhook tested.
* Exit criteria for warn (≤30 days; if still offenders, extend aliases or keep warn for noisy teams).
* RTO/RPO drill steps (time each step, record in runbook).

> The handoff already lists the skeleton and files to update (OpenAPI, ADR‑011, alerts). This fills the missing pieces. 

**Alert rules (PromQL)**

* “Warn rate high”, “Reject rate high”, “Latency p99 > 1ms 5m”, all pointing to the runbook URL above.

**OpenAPI**

* For affected endpoints, add `Deprecation`, `Sunset`, `Link: rel="deprecations"`, and the custom `X-Stage-*` headers with examples.

**CHANGELOG**

* Add the breaking‑change note + migration guide links at release time (you already model CHANGELOG entries for this program). 

---

## 9) NotebookLM: simple, safe gate

* Keep the **LLM‑as‑Judge** (≥92%) you already operate for docs, then run a **10‑item human checklist** (terminology, examples, edge cases, conflict resolution, error semantics).
* Only introduce calibration sets if you detect score drift over time.

---

## 10) PR plan (small, reviewable slices)

1. **PR‑Routes**: Wire 3 routes + unit tests for mode/header logic.
2. **PR‑Tests**: Integration (9 scenarios) + micro‑bench + perf baseline file.
3. **PR‑Obs**: Alert rules + webhook route + **prom config** + docs links.
4. **PR‑Docs**: Runbook + OpenAPI + ADR‑011 addendum + CHANGELOG.
5. **PR‑Rollout**: Env toggles, day‑by‑day script, and final migration “apply” checklist.

> Keep the **client WIP** isolated in its own branch/PR for later review.

---

## 11) Verification checklist (run these now)

* **Existence & dry‑run**

  ```bash
  npx tsx scripts/normalize-stages.ts --help
  npx tsx scripts/normalize-stages.ts            # dry-run
  ./scripts/backup-stages.sh --verify-only       # if you support a verify flag
  ```

  (These scripts are present and described as production‑ready.) 

* **Tests to spot regressions quickly**

  ```bash
  npm test -- tests/integration/stage-*.test.ts
  npm test -- tests/perf/monte-carlo-large-array.test.ts
  ```

  (Add the micro‑bench, but reuse the existing perf suite.)

* **Metrics labels sanity**
  Ensure the metric family and labels match the **low‑cardinality** design in your memo. 

---

## 12) Why this plan fits “the grand scheme”

* It picks up **exactly at Phase 4** per your Stage Normalization memo, finishes **5–6**, and executes rollout. 
* It **reuses** the heavy lifting already completed (DB, scripts, typed normalizer, statistical tests). 
* It formalizes **observability + rollback** with minimal code, high safety.
* It keeps **NotebookLM** alive as a gate (not a blocker), aligning with your validation culture.
* It unblocks follow‑on tracks (IA consolidation, parity, proposal workflow) by keeping this change isolated and fast.

---

### TL;DR action items (start of day)

1. **Isolate client churn** (branch snapshot).
2. **Implement the three route hooks** (copy the handler pattern from the memo). 
3. **Add tests** (unit + 9 integration scenarios) and **micro‑bench**.
4. **Wire Alertmanager → webhook**, add non‑prod toggle route, write **runbook** + **OpenAPI**.
5. **Rollout off → warn → apply → canary enforce** under the thresholds & auto‑downgrade.

You’ll finish Stage Validation v3 as designed, without re‑writing what’s already done, and with safer rollback, clearer exit criteria, and no cardinality traps.
