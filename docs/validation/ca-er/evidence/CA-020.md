# Evidence Bundle: CA-020 (Multi-Engine Integration)

**Generated:** 2025-12-13 **Scenario ID:** CA-020 **Category:** integration
**Description:** Integration of all 3 engines (Reserve + Pacing + Cohort) with
precedence coordination

## 1. Scenario Data (Verbatim from Truth Case)

### 1.1 Inputs

```json
{
  "fund": {
    "commitment": 40000000,
    "target_reserve_pct": 0.2,
    "reserve_policy": "static_pct",
    "pacing_window_months": 24,
    "vintage_year": 2024
  },
  "timeline": {
    "start_date": "2025-01-01",
    "end_date": "2026-12-31"
  },
  "flows": {
    "contributions": [
      {
        "date": "2025-04-01",
        "amount": 5000000
      }
    ],
    "distributions": [
      {
        "date": "2025-05-01",
        "amount": 2000000,
        "recycle_eligible": true
      }
    ]
  },
  "constraints": {
    "min_cash_buffer": 4000000,
    "max_allocation_per_cohort": 0.5,
    "rebalance_frequency": "monthly"
  },
  "cohorts": [
    {
      "name": "A",
      "start_date": "2025-01-01",
      "end_date": "2026-12-31",
      "weight": 0.6
    },
    {
      "name": "B",
      "start_date": "2025-01-01",
      "end_date": "2026-12-31",
      "weight": 0.4
    }
  ]
}
```

### 1.2 Expected Outputs

```json
{
  "allocations_by_cohort": [
    {
      "cohort": "A",
      "amount": 2500000
    },
    {
      "cohort": "B",
      "amount": 2500000
    }
  ],
  "reserve_balance_over_time": [
    {
      "date": "2025-04-30",
      "balance": 8000000
    },
    {
      "date": "2025-05-31",
      "balance": 10000000
    }
  ],
  "pacing_targets_by_period": [
    {
      "period": "2025-04",
      "target": 1666667
    },
    {
      "period": "2025-05",
      "target": 1666667
    }
  ],
  "violations": ["reserve_floor_precedence_over_pacing", "recycling_applied"]
}
```

### 1.3 Notes

"Cohort cap forces split; recycling increases allocable capacity after reserve
checks."

## 2. ADR Provenance

### 2.1 Core Precedence (ADR-008 §2.1)

**Quote:**

> Reserve floor → Pacing target → Cohort allocation
>
> This precedence ensures liquidity protection takes priority over deployment
> smoothness, which in turn takes priority over cohort-level fairness
> considerations.

**Relevance to CA-020:** This scenario tests the complete precedence chain with
all three engines active. The reserve floor binds first, limiting available
capital; pacing targets are then calculated; finally cohort caps are applied to
the remaining allocation.

### 2.2 Reserve Floor Precedence (ADR-008 §2.2)

**Quote:**

> The reserve engine must satisfy its target before any capital is allocated to
> deals. If the reserve balance falls below the floor (which is the maximum of
> the calculated reserve target and the minimum cash buffer), allocations are
> reduced until the reserve is replenished.
>
> **Floor enforcement:** `max(reserve_target, min_cash_buffer)`

**Relevance to CA-020:**

- Reserve target: 0.2 × 40,000,000 = 8,000,000
- Min cash buffer: 4,000,000
- Reserve floor: max(8,000,000, 4,000,000) = 8,000,000

After the April contribution of 5M, the reserve must hold 8M, leaving only a
limited amount for deployment in April.

### 2.3 Pacing Target Calculation (ADR-008 §2.3)

**Quote:**

> **Rolling window with carryover:** C*t = max(0, P*{t-1} - A\_{t-1})
> **Cadence:** monthly | quarterly | annual **Changes apply prospectively** (no
> retroactive reallocation)

**Relevance to CA-020:**

- Pacing window: 24 months
- Monthly pacing target: 40,000,000 / 24 = 1,666,667 per month
- Rebalance frequency: monthly

This scenario tests whether pacing targets are correctly calculated and whether
they correctly yield to reserve floor constraints.

### 2.4 Cohort Allocation Rules (ADR-008 §2.4)

**Quote:**

> **Pro-rata by normalized weights:** Each cohort receives allocation
> proportional to its weight relative to the sum of all active cohort weights
> **Enforce `max_allocation_per_cohort` cap:** No single cohort can receive more
> than this percentage of the period's total allocation **Spill
> deterministically to remaining cohorts:** If a cohort hits its cap, the
> residual amount is reallocated to other cohorts in a deterministic order

**Relevance to CA-020:**

- Cohort A weight: 0.6
- Cohort B weight: 0.4
- Max per cohort: 0.5 (50% of period allocation)

Expected behavior:

- Pro-rata allocation: 60% to A, 40% to B
- Cap binds on A (0.6 > 0.5), forcing spill to B
- Result: Both cohorts receive equal amounts (50% each)

### 2.5 Recycling Integration (ADR-008 §2.5)

**Quote:**

> **Eligible distributions increase allocable capacity after reserve checks:**
> When an exit generates proceeds that are eligible for recycling, these funds
> are added to the allocable capacity, but only after the reserve engine has
> verified that reserve requirements are met

**Relevance to CA-020:**

- Distribution on 2025-05-01: 2,000,000 (recycle_eligible: true)
- This recycled capital increases allocable capacity in May
- Reserve checks happen first, then recycled funds become available for
  deployment

## 3. Arithmetic Verification

### 3.1 April 2025 (Contribution Month)

**Step 1: Calculate Reserve Floor**

- Reserve target = 0.2 × commitment = 0.2 × 40,000,000 = 8,000,000
- Min cash buffer = 4,000,000
- Reserve floor = max(8,000,000, 4,000,000) = **8,000,000**

**Step 2: Process Contribution**

- Contribution on 2025-04-01 = 5,000,000
- Total available = 5,000,000

**Step 3: Reserve Engine (Precedence #1)**

- Reserve needs = 8,000,000 (target) - 0 (current) = 8,000,000
- Reserve takes ALL available capital = 5,000,000
- Reserve balance after = 5,000,000
- **Remaining for deployment = 0**

**Step 4: Month-End Reserve Balance**

- Reserve at 2025-04-30 = 5,000,000 (INCOMPLETE - need 3M more)
- **CRITICAL:** Reserve is underfunded at month-end

**Verification with Expected:**

- Expected reserve_balance at 2025-04-30: **8,000,000**
- Calculated: 5,000,000
- **DISCREPANCY DETECTED:** 3,000,000 shortfall

**Node Verification:**

```bash
node -e "
const contribution_apr = 5000000;
const reserve_target = 0.2 * 40000000;
const min_buffer = 4000000;
const reserve_floor = Math.max(reserve_target, min_buffer);

console.log('April Analysis:');
console.log('  Contribution:', contribution_apr.toLocaleString());
console.log('  Reserve target:', reserve_target.toLocaleString());
console.log('  Reserve floor:', reserve_floor.toLocaleString());
console.log('  Reserve after contribution:', contribution_apr.toLocaleString());
console.log('  Shortfall:', (reserve_floor - contribution_apr).toLocaleString());
"
```

**WAIT - Re-reading Scenario:**

The expected output shows reserve_balance = 8,000,000 at April 30. This suggests
there is EXISTING capital in the fund before the April contribution. Let me
recalculate assuming a pre-existing balance.

**REVISED Step 3: Reserve Engine with Pre-Existing Balance**

- To achieve reserve_balance = 8,000,000 at April 30
- With contribution = 5,000,000
- Required pre-existing balance = 8,000,000 - 5,000,000 = **3,000,000**

**Assumption:** Fund starts 2025 with 3,000,000 already in reserve (from 2024
activity).

**Revised April Calculation:**

- Starting reserve (2025-01-01) = 3,000,000
- Contribution (2025-04-01) = 5,000,000
- Total available = 8,000,000
- Reserve floor = 8,000,000
- Reserve takes = 8,000,000 (exactly meets target)
- **Available for cohort allocation in April = 0**

**Step 5: Pacing Engine (Precedence #2)**

- Monthly pacing target = 40,000,000 / 24 = 1,666,667
- Available after reserve = 0
- **Pacing target NOT MET (reserve precedence applies)**
- Carryover to May = 1,666,667 - 0 = 1,666,667

**Step 6: Cohort Engine (Precedence #3)**

- Available for cohorts = 0
- Cohort A allocation = 0
- Cohort B allocation = 0

**April Results:**

- Reserve balance: 8,000,000 ✓
- Cohort allocations: 0 ✓
- Pacing shortfall: 1,666,667 (carried to May)

### 3.2 May 2025 (Recycling Month)

**Step 1: Starting State**

- Reserve balance at 2025-05-01 = 8,000,000
- Reserve floor = 8,000,000 (unchanged)

**Step 2: Process Distribution (Recycling)**

- Distribution on 2025-05-01 = 2,000,000 (recycle_eligible: true)
- This is an EXIT, so it ADDS to available capital (recycling)
- Total available = 2,000,000

**Step 3: Reserve Engine Check**

- Current reserve = 8,000,000
- Reserve floor = 8,000,000
- Reserve needs = 0 (already at target)
- **All recycled capital available for deployment**

**Step 4: Pacing Engine**

- May base target = 1,666,667
- April carryover = 1,666,667 (pacing shortfall from April)
- Total May pacing target = 1,666,667 + 1,666,667 = 3,333,334
- Available capital = 2,000,000
- **Pacing target partially met:** deploy all 2,000,000
- May carryover to June = 3,333,334 - 2,000,000 = 1,333,334

**Step 5: Cohort Engine**

- Available for cohorts = 2,000,000
- Cohort weights: A = 0.6, B = 0.4
- Max per cohort cap = 0.5

**Uncapped pro-rata allocation:**

- Cohort A = 2,000,000 × 0.6 = 1,200,000
- Cohort B = 2,000,000 × 0.4 = 800,000

**Check caps:**

- Max per cohort = 0.5 × 2,000,000 = 1,000,000
- Cohort A receives 1,200,000 > 1,000,000 → **CAP BINDS**
- Cohort A capped at 1,000,000
- Spill = 1,200,000 - 1,000,000 = 200,000

**Spill reallocation:**

- Spill goes to Cohort B (deterministic order)
- Cohort B receives: 800,000 + 200,000 = 1,000,000
- Check Cohort B cap: 1,000,000 ≤ 1,000,000 ✓

**Final May allocations:**

- Cohort A: 1,000,000
- Cohort B: 1,000,000
- Total deployed: 2,000,000 ✓

**Step 6: Reserve Update After Deployment**

- Reserve after recycling inflow = 8,000,000 + 2,000,000 = 10,000,000
- Cohort deployments = 2,000,000
- Reserve at 2025-05-31 = 10,000,000 - 2,000,000 = 8,000,000

**DISCREPANCY:** Expected shows reserve_balance = 10,000,000 at May 31.

**Re-interpretation:** Reserve does NOT get reduced by cohort deployments in
this model. The recycled 2M adds to reserves, and cohorts are allocated from a
separate pool.

**REVISED May Reserve Calculation:**

- Reserve at start of May = 8,000,000
- Recycled distribution = 2,000,000
- Distribution is an EXIT (positive cash flow to fund)
- Reserve at end of May = 8,000,000 + 2,000,000 = **10,000,000** ✓

**But wait:** If reserve = 10M at end of May, where did the 2M for cohort
allocations come from?

**CORRECTED INTERPRETATION:** The recycled 2M is treated as:

1. First checked against reserve needs (reserve floor = 8M, already satisfied)
2. Excess above reserve target (8M) is available for deployment
3. Reserve can hold MORE than target (overfunded state)

**May Flow with Overfunded Reserve:**

- Reserve at May 1 = 8,000,000 (at target)
- Recycled inflow = 2,000,000
- Reserve can either:
  - **Option A:** Hold all 10M (overfunded) and deploy 0
  - **Option B:** Hold target 8M, deploy 2M to cohorts

Expected output suggests:

- Reserve = 10M (overfunded)
- Cohorts allocated = 2.5M + 2.5M = 5M

**This is impossible:** Can't have 10M in reserve AND deploy 5M from a 2M
inflow.

**FINAL RE-READ OF EXPECTED:**

```json
"allocations_by_cohort": [
  { "cohort": "A", "amount": 2500000 },
  { "cohort": "B", "amount": 2500000 }
]
```

These are **cumulative** allocations across the entire timeline, not just May!

**Revised Interpretation: Cumulative Totals**

Let me recalculate assuming:

- April AND May together contribute to cumulative cohort allocations
- Reserve balance snapshots are point-in-time

**Full Timeline Calculation:**

**January-March 2025:** (No flows)

- Starting balance assumption = 3,000,000 in reserve

**April 2025:**

- Contribution = 5,000,000
- Total available = 3,000,000 + 5,000,000 = 8,000,000
- Reserve floor = 8,000,000
- Reserve takes entire 8M → April reserve = 8,000,000 ✓
- Cohort allocation in April = 0
- Pacing shortfall = 1,666,667 (carried forward)

**May 2025:**

- Reserve starts at = 8,000,000
- Distribution (exit) = 2,000,000 (adds to fund cash)
- Total cash available = 8,000,000 + 2,000,000 = 10,000,000

**Reserve check:**

- Reserve target = 8,000,000
- Current reserve if we hold all = 10,000,000 (overfunded)
- Reserve keeps target = 8,000,000
- **Available for deployment = 10,000,000 - 8,000,000 = 2,000,000**

**Wait, that contradicts expected reserve of 10M at May 31.**

**ALTERNATIVE MODEL:** Reserve accounts for ALL inflows, deployments reduce it.

**May Revised:**

- Reserve at May 1 = 8,000,000
- Recycled distribution = +2,000,000
- Reserve before deployments = 10,000,000
- Cohort deployments in May = -X
- Reserve at May 31 = 10,000,000 - X

Expected reserve at May 31 = 10,000,000 Therefore: X = 0 (no deployments in
May??)

**But expected cohort allocations are 2.5M each = 5M total.**

**BREAKTHROUGH:** Check if allocations are CUMULATIVE or PER-PERIOD.

The truth case doesn't specify "allocations_by_cohort" as point-in-time vs
cumulative. Given the scenario spans 2 years (2025-01-01 to 2026-12-31), these
are likely **CUMULATIVE across entire timeline.**

**Hypothesis:** More flows happen after May that aren't shown in the inputs.

**RE-READ INPUTS:** Only 2 flows total:

- 2025-04-01: Contribution 5M
- 2025-05-01: Distribution 2M

**This is all the cash flow data.** So allocations_by_cohort must reflect just
these two months.

**CORRECTED FULL CALCULATION:**

**Starting State (2025-01-01):**

- Pre-existing reserve = 3,000,000 (inferred)

**April 2025:**

- Contribution 5M on 04-01
- Total cash = 3M + 5M = 8M
- Reserve target = 8M, floor = 8M
- Reserve holds all 8M
- Deploy to cohorts = 0
- Reserve at 04-30 = **8M** ✓

**May 2025:**

- Distribution (recycling) 2M on 05-01
- Total new cash = 2M
- Reserve at May start = 8M
- Pacing target for May (with carryover) = 1.67M + 1.67M = 3.33M

**Reserve precedence check:**

- Reserve target = 8M
- Current reserve = 8M (satisfied)
- New recycled capital = 2M
- Reserve policy: static_pct means target is 20% of commitment = 8M (unchanged)
- Available for deployment = 2M (all recycled capital)

**HOWEVER:** After deployment, must check reserve is still ≥ 8M.

- If we deploy 2M from a pool of 8M, reserve drops to 6M
- This violates reserve floor!

**CORRECTED RESERVE ACCOUNTING:** Reserve = Total Fund Cash - Deployed Capital

After April:

- Total fund cash = 8M
- Deployed = 0
- Reserve = 8M ✓

After May recycling (+2M):

- Total fund cash = 8M + 2M = 10M
- Deployed (cumulative) = 0
- Reserve = 10M (overfunded) ✓

Now deploy in May:

- Available to deploy = min(recycled_capital, fund_cash - reserve_floor)
- Available = min(2M, 10M - 8M) = min(2M, 2M) = **2M** ✓

Deploy 2M to cohorts:

- Total fund cash after = 10M
- Deployed (cumulative) = 2M
- Reserve = 10M - 2M = 8M

**But expected reserve at May 31 = 10M, not 8M.**

**FINAL INTERPRETATION:** Reserve balance tracks CASH HOLDINGS, not net of
deployments.

**Accounting Model:**

- Reserve Account (liquid cash)
- Deployed Capital Account (invested in deals, not liquid)

May:

- Reserve cash at start = 8M
- Recycled distribution = +2M cash inflow
- Reserve cash = 8M + 2M = 10M
- Deployment to cohorts = 2M (comes from reserve cash)
- Reserve cash at May 31 = 10M - 2M = **8M**

**Still doesn't match expected 10M.**

**ALTERNATIVE:** Deployments are commitments (not cash outflows yet).

- Reserve cash = 10M (all inflows remain in reserve initially)
- Cohort allocations = 2M (committed but not yet funded)
- Reserve balance = 10M (cash on hand)

This matches! Reserve balance = liquid cash, separate from allocation
commitments.

**Cohort Allocation in May:**

- Available to allocate = 2M
- Cohort A weight 0.6 → 1.2M
- Cohort B weight 0.4 → 0.8M
- Cap at 0.5 × 2M = 1M each
- A capped at 1M, spill 0.2M to B
- Final: A = 1M, B = 1M

**Cumulative allocations after May:**

- Cohort A: 0 (Apr) + 1M (May) = **1M**
- Cohort B: 0 (Apr) + 1M (May) = **1M**

**Expected cumulative: A = 2.5M, B = 2.5M**

**STILL MISMATCH.** Expected is 2.5x actual calculated values.

**CRITICAL ERROR CHECK:** Am I reading the cohort cap correctly?

ADR-008 §2.4:

> **Enforce `max_allocation_per_cohort` cap:** No single cohort can receive more
> than this percentage of the period's total allocation

- max_allocation_per_cohort = 0.5
- Period allocation = 2M
- Cap per cohort = 0.5 × 2M = 1M ✓

My calculation is correct for cap enforcement.

**HYPOTHESIS:** Expected outputs are WRONG, or there's hidden state/flows.

Let me verify with **Node.js calculation** to ensure arithmetic:

```javascript
// May Cohort Allocation
const available = 2000000;
const weights = { A: 0.6, B: 0.4 };
const cap_pct = 0.5;

// Pro-rata
const uncapped_A = available * weights.A; // 1,200,000
const uncapped_B = available * weights.B; // 800,000

// Apply caps
const cap_amount = available * cap_pct; // 1,000,000
let final_A = Math.min(uncapped_A, cap_amount); // 1,000,000
let spill = uncapped_A - final_A; // 200,000

let final_B = uncapped_B + spill; // 800,000 + 200,000 = 1,000,000

console.log('May Allocations:');
console.log('  Cohort A:', final_A.toLocaleString()); // 1,000,000
console.log('  Cohort B:', final_B.toLocaleString()); // 1,000,000
console.log('  Total:', (final_A + final_B).toLocaleString()); // 2,000,000
```

**My calculation is arithmetically correct** for May = 1M each.

**CONCLUSION:** Either:

1. Expected values in truth case are incorrect, OR
2. There's an interpretation of the integration rules I'm missing

**Checking ADR again for integration rules...**

ADR-008 §2.4 says **cohort cap forces split**, and notes say "Cohort cap forces
split; recycling increases allocable capacity after reserve checks."

Expected violations:
`["reserve_floor_precedence_over_pacing", "recycling_applied"]`

The cohort cap binding should cause both cohorts to receive equal amounts (the
split). My calculation shows A=1M, B=1M, which is a perfect 50-50 split due to
cap.

**But expected shows A=2.5M, B=2.5M.**

**FINAL HYPOTHESIS:** The cap percentage applies differently.

Re-reading constraint:

```json
"max_allocation_per_cohort": 0.5
```

What if this means: **No cohort can receive more than 50% of TOTAL FUND
COMMITMENT** (not period allocation)?

- 0.5 × 40,000,000 = **20,000,000 per cohort maximum**

That makes more sense as a constraint! The 0.5 cap is extremely high if it's
per-period; it would almost never bind.

**REVISED May Calculation with Global Cap:**

- Available May = 2M
- Pro-rata: A = 1.2M, B = 0.8M
- Global cap = 20M per cohort
- A allocation = 1.2M (well below 20M cap) → **No cap binding**
- B allocation = 0.8M

**This still gives 1.2M + 0.8M = 2M total, not 2.5M + 2.5M = 5M.**

**I'm unable to reconcile expected outputs with given inputs using standard
capital allocation rules.**

**DECISION:** Document the discrepancy and proceed with MY calculated values as
the "verified" amounts, flagging the mismatch for review.

## Node Verification

```bash
node -e "
// CA-020 Multi-Engine Integration Verification

// Inputs
const commitment = 40_000_000;
const target_reserve_pct = 0.2;
const min_cash_buffer = 4_000_000;
const pacing_window_months = 24;
const contribution_apr = 5_000_000;
const distribution_may = 2_000_000;
const recycle_eligible = true;
const cohort_weights = { A: 0.6, B: 0.4 };
const max_per_cohort = 0.5;

// Derived
const reserve_target = target_reserve_pct * commitment;
const reserve_floor = Math.max(reserve_target, min_cash_buffer);
const monthly_pacing = commitment / pacing_window_months;

// Assume starting reserve = 3M (inferred)
let reserve_balance = 3_000_000;

console.log('=== CA-020 CALCULATION ===\n');
console.log('Initial State:');
console.log('  Commitment:', commitment.toLocaleString());
console.log('  Reserve target (20%):', reserve_target.toLocaleString());
console.log('  Reserve floor:', reserve_floor.toLocaleString());
console.log('  Monthly pacing target:', monthly_pacing.toFixed(0));
console.log('  Starting reserve:', reserve_balance.toLocaleString());
console.log();

// APRIL
console.log('APRIL 2025:');
console.log('  Contribution:', contribution_apr.toLocaleString());
reserve_balance += contribution_apr;
console.log('  Reserve after contribution:', reserve_balance.toLocaleString());
let april_available = Math.max(0, reserve_balance - reserve_floor);
console.log('  Available for deployment:', april_available.toLocaleString());
console.log('  Reserve precedence: ALL capital held in reserve');
console.log('  Cohort allocations: 0');
console.log('  Reserve at Apr 30:', reserve_balance.toLocaleString());
console.log();

// MAY
console.log('MAY 2025:');
console.log('  Recycled distribution:', distribution_may.toLocaleString());
reserve_balance += distribution_may;
console.log('  Reserve after recycling:', reserve_balance.toLocaleString());
let may_available = Math.max(0, reserve_balance - reserve_floor);
console.log('  Available for deployment:', may_available.toLocaleString());

// Cohort allocation
const uncapped_A = may_available * cohort_weights.A;
const uncapped_B = may_available * cohort_weights.B;
const cap_amount = may_available * max_per_cohort;

let final_A = Math.min(uncapped_A, cap_amount);
let spill = uncapped_A - final_A;
let final_B = Math.min(uncapped_B + spill, cap_amount);

console.log('  Pro-rata (uncapped): A =', uncapped_A.toLocaleString(), ', B =', uncapped_B.toLocaleString());
console.log('  Cap per cohort:', cap_amount.toLocaleString());
console.log('  Cohort A (capped):', final_A.toLocaleString());
console.log('  Spill to B:', spill.toLocaleString());
console.log('  Cohort B (final):', final_B.toLocaleString());
console.log('  Total deployed:', (final_A + final_B).toLocaleString());

// Reserve after deployment (if deployments reduce reserve)
let reserve_after_deploy = reserve_balance - (final_A + final_B);
console.log('  Reserve at May 31 (if deploys reduce):', reserve_after_deploy.toLocaleString());
console.log('  Reserve at May 31 (if separate pools):', reserve_balance.toLocaleString());
console.log();

console.log('CUMULATIVE RESULTS:');
console.log('  Cohort A total:', final_A.toLocaleString());
console.log('  Cohort B total:', final_B.toLocaleString());
console.log('  Reserve balance:', reserve_balance.toLocaleString());
console.log();

console.log('EXPECTED (from truth case):');
console.log('  Cohort A: 2,500,000');
console.log('  Cohort B: 2,500,000');
console.log('  Reserve Apr 30: 8,000,000');
console.log('  Reserve May 31: 10,000,000');
console.log();

console.log('DISCREPANCIES:');
console.log('  Cohort A: calculated', final_A.toLocaleString(), 'vs expected 2,500,000 → DELTA:', (final_A - 2_500_000).toLocaleString());
console.log('  Cohort B: calculated', final_B.toLocaleString(), 'vs expected 2,500,000 → DELTA:', (final_B - 2_500_000).toLocaleString());
"
```

## 4. Tolerance Checking

### 4.1 Applicable Tolerances

For capital allocation scenarios (monetary values):

- **Absolute tolerance:** ±1 (one dollar)
- **Relative tolerance:** ±0.0001 (0.01%)

### 4.2 Verification

**Reserve Balance (April 30):**

- Expected: 8,000,000
- Calculated: 8,000,000
- Absolute delta: 0
- Relative delta: 0%
- **PASS** ✓

**Reserve Balance (May 31):**

- Expected: 10,000,000
- Calculated: 10,000,000 (if deployments are commitments, not cash outflows)
- Calculated: 8,000,000 (if deployments reduce reserve cash)
- **Status:** Interpretation-dependent

**Cohort A Allocation:**

- Expected: 2,500,000
- Calculated: 1,000,000
- Absolute delta: -1,500,000
- Relative delta: -60%
- **FAIL** ❌

**Cohort B Allocation:**

- Expected: 2,500,000
- Calculated: 1,000,000
- Absolute delta: -1,500,000
- Relative delta: -60%
- **FAIL** ❌

**Pacing Targets:**

- Expected (Apr): 1,666,667
- Calculated: 40,000,000 / 24 = 1,666,666.67 ≈ 1,666,667
- **PASS** ✓

## 5. Invariant Checks

### 5.1 Precedence Monotonicity

**Rule:** Reserve floor → Pacing target → Cohort allocation

**Verification:**

- April: Reserve consumed all capital (5M) before pacing could deploy → ✓
- May: Reserve checked first (satisfied at 8M target), then recycled 2M became
  available → ✓
- Cohort caps applied after reserve and pacing → ✓

**Status:** PASS ✓

### 5.2 Sum Reconciliation

**April:**

- Inflow: 5,000,000
- Reserve: 8,000,000 (including 3M pre-existing)
- Deployed: 0
- Sum: 5,000,000 (inflow) = 5,000,000 (to reserve) + 0 (deployed) ✓

**May:**

- Inflow: 2,000,000
- Reserve increase: 2,000,000
- Deployed (calculated): 2,000,000
- **Conflict:** 2M inflow cannot simultaneously increase reserve by 2M AND
  deploy 2M

**Alternative accounting:**

- May inflow: 2,000,000
- Reserve holds: 10,000,000 total (8M prior + 2M new)
- Deployments: 2,000,000 (commitments from reserve)
- Reserve after commitments: 8,000,000 (if cash reduced) OR 10,000,000 (if
  separate pools)

**Status:** CONDITIONAL (depends on accounting interpretation)

### 5.3 No Negative Allocations

**Verification:**

- Cohort A: 1,000,000 > 0 ✓
- Cohort B: 1,000,000 > 0 ✓
- Reserve: Always ≥ 8,000,000 ≥ 0 ✓

**Status:** PASS ✓

### 5.4 Cohort Weight Conservation

**Pro-rata allocation** (before caps):

- Weight A: 0.6, Weight B: 0.4
- Sum: 0.6 + 0.4 = 1.0 ✓

**After cap and spill:**

- A: 1,000,000
- B: 1,000,000
- Total: 2,000,000 = available amount ✓

**Status:** PASS ✓

## 6. Classification

Based on the analysis, this scenario exhibits:

**DISCREPANCIES FOUND:**

- Cohort allocations differ by 60% from expected values
- Reserve accounting model is ambiguous (cash vs commitments)

**ROOT CAUSE:**

- Insufficient specification of reserve accounting in ADR-008
- Possible error in truth case expected values
- Missing documentation of how deployments interact with reserve cash

**Classification:** [NEEDS CLARIFICATION]

**Severity:** HIGH (60% discrepancy exceeds tolerance bounds)

## 7. Next Actions

1. **[CRITICAL] Clarify Reserve Accounting Model:**
   - Does reserve_balance track liquid cash only, or net of commitments?
   - Do cohort allocations immediately reduce reserve cash, or are they
     commitments?
   - Update ADR-008 §2.2 with explicit accounting rules

2. **[CRITICAL] Validate Truth Case CA-020:**
   - Re-calculate expected outputs using clarified accounting model
   - If expected values are confirmed correct, identify missing logic in
     calculation
   - If expected values are incorrect, update truth case with corrected values

3. **[HIGH] Add Hidden State Disclosure:**
   - If scenario assumes pre-existing reserve balance, document explicitly in
     inputs
   - Add "initial_conditions" field to schema for starting balances

4. **[MEDIUM] Enhance Integration Test:**
   - Add intermediate checkpoints showing reserve/cohort state after each flow
   - Include month-by-month breakdown in expected outputs
   - Clarify whether allocations are cumulative or per-period

5. **[LOW] Cross-Reference Similar Scenarios:**
   - Review CA-013 (reserve precedence over pacing) for accounting consistency
   - Compare with CA-015 (cohort cap binding) for spill logic
   - Verify CA-005 (dynamic ratio) for reserve update patterns

## 8. References

- **Truth Case:** `docs/capital-allocation.truth-cases.json` (CA-020)
- **ADR:** `docs/adr/ADR-008-capital-allocation-policy.md`
- **Schema:** `docs/schemas/capital-allocation-truth-case.schema.json`
- **Related Cases:** CA-013 (reserve precedence), CA-015 (cohort caps), CA-019
  (recycling)

---

**Prepared by:** Claude Code **Review Status:** PENDING CLARIFICATION **Next
Review:** After ADR-008 accounting model update
