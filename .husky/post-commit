#!/usr/bin/env sh

# Auto-track TypeScript baseline updates
# Detects if .tsc-baseline.json was in the commit and logs to feedback

BASELINE_FILE=".tsc-baseline.json"
FEEDBACK_FILE=".agents-feedback.md"

# Check if baseline was modified in this commit
if git diff --name-only HEAD^ HEAD 2>/dev/null | grep -q "^${BASELINE_FILE}$"; then
  # Extract commit message
  COMMIT_MSG=$(git log -1 --pretty=%B)

  # Check if commit message indicates error fixing (not just baseline creation)
  if echo "$COMMIT_MSG" | grep -qiE "fix|resolve|correct|update.*error"; then
    # Auto-log the session (only if not already tracked manually)
    LAST_SESSION=$(tail -n 20 "$FEEDBACK_FILE" 2>/dev/null | grep -c "$(date +%Y-%m-%d)")
    LAST_SESSION=${LAST_SESSION:-0}

    if [ "$LAST_SESSION" -eq 0 ]; then
      # Parse baseline changes from commit (cross-platform compatible)
      BASELINE_BEFORE=$(git show HEAD^:"$BASELINE_FILE" 2>/dev/null | grep '"totalErrors"' | sed 's/.*"totalErrors":\s*\([0-9]*\).*/\1/' || echo "unknown")
      BASELINE_AFTER=$(git show HEAD:"$BASELINE_FILE" 2>/dev/null | grep '"totalErrors"' | sed 's/.*"totalErrors":\s*\([0-9]*\).*/\1/' || echo "unknown")

      # Calculate errors fixed
      if [ "$BASELINE_BEFORE" != "unknown" ] && [ "$BASELINE_AFTER" != "unknown" ]; then
        ERRORS_FIXED=$((BASELINE_BEFORE - BASELINE_AFTER))

        if [ $ERRORS_FIXED -gt 0 ]; then
          # Auto-log successful TypeScript error fixing session
          cat >> "$FEEDBACK_FILE" <<EOF

### $(date +%Y-%m-%d) - Auto-tracked
**Task**: TypeScript error fixing (detected from commit)
**Outcome**: success
**Duration**: Auto-tracked
**Notes**: Fixed $ERRORS_FIXED error(s). Baseline: $BASELINE_BEFORE â†’ $BASELINE_AFTER
**AGENTS.md Update**: Auto-tracked (review if needed)

---
EOF
          echo "ðŸ“ Auto-tracked TypeScript baseline improvement ($ERRORS_FIXED errors fixed)"
        fi
      fi
    fi
  fi
fi

# Auto-track phase completions
# Detects commits like "Complete Phase 0A" or "feat(portfolio): Complete Phase..."
COMMIT_MSG=$(git log -1 --pretty=%B)
PHASE_STATUS_FILE="docs/PHASE-STATUS.json"

if echo "$COMMIT_MSG" | grep -qiE "(complete|finish|done).*(phase|step|milestone)"; then
  # Extract phase identifier (e.g., "Phase 0A", "Phase 1", etc.)
  PHASE_ID=$(echo "$COMMIT_MSG" | grep -oiE "phase [0-9]+[a-z]?" | head -1)

  if [ -n "$PHASE_ID" ]; then
    echo "Phase completion detected: $PHASE_ID"

    # Create or update PHASE-STATUS.json
    if [ ! -f "$PHASE_STATUS_FILE" ]; then
      mkdir -p "$(dirname "$PHASE_STATUS_FILE")"
      echo '{"phases":[]}' > "$PHASE_STATUS_FILE"
    fi

    # Add completion entry using node
    node -e "
      const fs = require('fs');
      const path = '$PHASE_STATUS_FILE';
      let data = JSON.parse(fs.readFileSync(path, 'utf-8'));
      const phaseId = '$PHASE_ID';
      const timestamp = new Date().toISOString();
      const commitHash = '$(git rev-parse HEAD)';

      // Update or add phase entry
      const existingIndex = data.phases.findIndex(p => p.id === phaseId);
      const entry = {
        id: phaseId,
        completedAt: timestamp,
        commit: commitHash,
        message: \`$COMMIT_MSG\`.trim()
      };

      if (existingIndex >= 0) {
        data.phases[existingIndex] = entry;
      } else {
        data.phases.push(entry);
      }

      fs.writeFileSync(path, JSON.stringify(data, null, 2));
      console.log('Updated $PHASE_STATUS_FILE');
    " || echo "Could not update phase status (non-critical)"

    # Flag handoff documents as potentially stale
    HANDOFF_DOCS=$(find docs/sessions -name "*HANDOFF*.md" 2>/dev/null | head -5)
    if [ -n "$HANDOFF_DOCS" ]; then
      echo "Consider updating handoff documents for $PHASE_ID:"
      echo "$HANDOFF_DOCS" | while read doc; do
        echo "   - $doc"
      done
    fi
  fi
fi

# Explicit success exit to prevent false failures from conditional checks
exit 0
